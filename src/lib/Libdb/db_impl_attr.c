/*
 * Copyright (C) 1994-2018 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */


/**
 * @file    db_postgres_attr.c
 *
 * @brief
 *	Implementation of the attribute related functions for postgres
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */
#include <string.h>
#include "pbs_db.h"
#include "db_impl.h"


/**
 * @brief
 *	Converts a postgres jsonb[] to attribute list.
 *
 * @param[in]	buf - String which is in the form of postgres jsonb[]
 * @param[out]  attr_list - List of pbs_db_attr_list_t objects
 *
 * @return      Error code
 * @retval	-1 - On Error
 * @retval	 0 - On Success
 * @retval	>1 - Number of attributes
 *
 */
int
convert_asmap_to_db_attr_list(as_hashmap *attrmap, pbs_db_attr_list_t *attr_list)
{
	pbs_db_attr_info_t *attrs = NULL;
	as_pair* p_pair;
	const char* p_key;
	const char* p_val;
	int i = 0;
	char *p;
	as_hashmap_iterator *it = as_hashmap_iterator_new(attrmap);

	attr_list->attr_count = 0;
	attr_list->attributes = NULL;

	attr_list->attr_count = as_hashmap_size(attrmap);
	if (attr_list->attr_count == 0) {
		return 0;
	}
	attrs = malloc(sizeof(pbs_db_attr_info_t)*attr_list->attr_count);
    if (!attrs) {
		attr_list->attr_count = 0;
        return -1;
	}
	attr_list->attributes = attrs;

	while(as_hashmap_iterator_has_next((as_hashmap_iterator *) it)) {
    	p_pair = (as_pair *) as_hashmap_iterator_next((as_hashmap_iterator *) it);

		p_key = as_string_get(as_string_fromval(as_pair_1(p_pair)));
		strcpy(attrs[i].attr_name, p_key);
		if (p = strchr(attrs[i].attr_name, '.')) {
			*p = '\0';
			strcpy(attrs[i].attr_resc, p+1);
		} else 
			attrs[i].attr_resc[0] = '\0';
		
		p_val = as_string_get(as_string_fromval(as_pair_2(p_pair)));
		p = strchr(p_val, '.');
		*p = '\0';
		attrs[i].attr_flags = strtoul(p_val, NULL, 10);
		attrs[i].attr_value = strdup(p + 1);
		i++;
	}
	as_hashmap_iterator_destroy(it);

	return 0;
}

/**
 * @brief
 *	Converts an attribute list to string array which is in the form of postgres jsonb[].
 *
 * @param[in]	attr_list - List of pbs_db_attr_list_t objects
 * @param[out]  outbuf - string which is in the form of postgres jsonb[]
 *
 * @return      Error code
 * @retval	-1 - On Error
 * @retval	 0 - On Success
 *
 */
int
convert_db_attr_list_to_asmap(as_hashmap *attrmap, pbs_db_attr_list_t *attr_list)
{
	int i;
	char buf[1024];
	char *attrbuf, *attrval;
	as_string *askey;
	as_string *asval;
	pbs_db_attr_info_t *attrs = attr_list->attributes;

	as_hashmap_init(attrmap, attr_list->attr_count);

	for (i = 0; i < attr_list->attr_count; i++) {
		if (attrs[i].attr_resc[0] != '\0') {
			sprintf(buf, "%s.%s", attrs[i].attr_name, attrs[i].attr_resc);
		} else {
			strcpy(buf, attrs[i].attr_name);
		}
		attrbuf = strdup(buf);
		askey = as_string_new(attrbuf, true);	

		sprintf(buf, "%d.%s", attrs[i].attr_flags, attrs[i].attr_value);
		attrval = strdup(buf);
		asval = as_string_new(attrval, true);

		as_hashmap_set(attrmap, (as_val*) askey, (as_val*) asval);
	}

	return 0;
}

/**
 * @brief
 *	Frees attribute list memory
 *
 * @param[in]	attr_list - List of pbs_db_attr_list_t objects
 *
 * @return      None
 *
 */
void
free_db_attr_list(pbs_db_attr_list_t *attr_list)
{
	if (attr_list->attributes != NULL) {
		if (attr_list->attr_count > 0) {
			int i;
			for (i=0; i < attr_list->attr_count; i++) {
				free(attr_list->attributes[i].attr_value);
			}
		}
		free(attr_list->attributes);
		attr_list->attributes = NULL;
	}
}
