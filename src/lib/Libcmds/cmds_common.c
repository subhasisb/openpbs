/*
 * Copyright (C) 1994-2021 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of both the OpenPBS software ("OpenPBS")
 * and the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * OpenPBS is free software. You can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * OpenPBS is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * PBS Pro is commercially licensed software that shares a common core with
 * the OpenPBS software.  For a copy of the commercial license terms and
 * conditions, go to: (http://www.pbspro.com/agreement.html) or contact the
 * Altair Legal Department.
 *
 * Altair's dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of OpenPBS and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair's trademarks, including but not limited to "PBS™",
 * "OpenPBS®", "PBS Professional®", and "PBS Pro™" and Altair's logos is
 * subject to Altair's trademark licensing policies.
 */

#include <pbs_config.h>
#include <stdlib.h>
#include <unistd.h>
#include <pbs_config.h>   /* the master config generated by configure */
#include <errno.h>
#include <arpa/inet.h>
#ifndef WIN32
#include <sys/un.h>
#include <errno.h>
#include <signal.h>
#endif
#include "cmds.h"
#include "credential.h"
#include "attribute.h"
#include "pbs_idx.h"

static void *cc_idx = NULL;
static struct batch_status *cc_head = NULL;
static struct batch_status *cc_tail = NULL;

/**
 * @brief
 *	Add an entry to an attribute list. First, create the entry and set
 * 	the fields. If the attribute list is empty, then just point it at the
 * 	new entry. Otherwise, append the new entry to the list.
 *
 *  This function is a wrapper of set_attr function in libpbs. It exits when
 *  a non-zero error code is returned by set_attr.
 *
 * @param[in/out] attrib - pointer to attribute list
 * @param[in]     attrib_name - attribute name
 * @param[in]     attrib_value - attribute value
 *
 * @return	Void
 */
void
set_attr_error_exit(struct attrl **attrib, char *attrib_name, char *attrib_value) {
    if (set_attr(attrib, attrib_name, attrib_value))
        exit(2);
}

/**
 * @brief
 *	wrapper function for set_attr_resc in libpbs. Exits if a non-zero error
 *  code is returned by set_attr_resc.
 *
 * @param[in/out] attrib - pointer to attribute list
 * @param[in]     attrib_name - attribute name
 * @param[in]     attrib_value - attribute value
 *
 * @return      Void
 */
void
set_attr_resc_error_exit(struct attrl **attrib, char *attrib_name, char *attrib_resc, char *attrib_value)
{
    if (set_attr_resc(attrib, attrib_name, attrib_resc, attrib_value))
        exit(2);
}

/*
 * Stub function of actual DIS_tpp_funcs for PBS clients commands
 * which doesn't use TPP
 */
void
DIS_tpp_funcs() { }

#ifdef WIN32
#ifdef DEBUG
/**
 * @brief
 *	Prints the result of GetLastError()
 */
static void
print_last_error(void)
{
	LPVOID lp_msg_buf;
	LPVOID lp_display_buf;
	DWORD dw = GetLastError();

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dw,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR) &lp_msg_buf,
		0, NULL);

	printf("%s\n", lp_msg_buf);
}
#endif
#endif

/******************************************************************************
 * client cache related function below
 * 
 *****************************************************************************/


#ifdef CLI_DEBUG
/*
 * brief - dump the contents of batch status list
 * used for debugging
 * 
 * If CLI_DEBUG is defined duraing compilation, then this function
 * can be used to dump the contents of a batch_status list
 * 
 */
void 
debug_print_bs(struct batch_status *bs)
{
	struct batch_status *p = bs;
	struct attrl *a;
	int doattribs = (getenv("CLI_DEBUG_ATTRS") != NULL);

	fprintf(stderr, "bs={");
	while (p) {
		
		if (doattribs == 0) {
			fprintf(stderr, "%s => ", p->name);
		} else {
			fprintf(stderr, "[%p] %s [%p]", p, p->name, p->next);
			fprintf(stderr, "\n");
			a = p->attribs;
			while (a) {
				fprintf(stderr, "\t{[%p] %s(%s)=%s [%p]}\n", a, a->name, a->resource, a->value, a->next);
				a = a->next;
			}
		}
		p = p->next;
	}
	fprintf(stderr, "}\n");
}
#endif

/**
 * @brief
 *	helper function to update an attr
 *
 * @param[in] oattrl - original array to be updated
 * @param[in] uattrl - new attribute to be updated to
 *
 */
static void 
update_attr(struct attrl *oattrl, struct attrl *uattrl)
{
	CLI_DBPRT((stderr, "Updating attribute %s(%s)=%s\n", uattrl->name, uattrl->resource, uattrl->value))
	free(oattrl->name);
	oattrl->name = uattrl->name;
	uattrl->name = NULL;
	
	free(oattrl->resource);
	oattrl->resource = uattrl->resource;
	uattrl->resource = NULL;

	free(oattrl->value);
	oattrl->value = uattrl->value;
	uattrl->value = NULL;
}

/**
 * @brief
 *	helper function to insert attr at the end of list
 *
 * @param[in] orig - original array of attributes
 * @param[in] last - ptr to last attribute after which to add
 * @param[in] uattrl - attribute to be inserted
 *
 */
static void
insert_attr(struct batch_status *orig, struct attrl *prev, struct attrl *uattrl)
{
	CLI_DBPRT((stderr, "Inserting attr %s(%s)=%s\n", uattrl->name, uattrl->resource, uattrl->value))
	if (prev) {
		uattrl->next = prev->next;
		prev->next = uattrl;
	} else {
		uattrl->next = NULL;
		orig->attribs = uattrl;
	}
}

/**
 * @brief
 *	Update the attributes of an object in the client cache
 *
 * @param[in] orig - original array of attributes
 * @param[in] upd  - array of updated attributes
 *
 */
static int 
cc_update_obj(struct batch_status *orig, struct batch_status *upd)
{
	struct attrl *uattrl, *prev_uattrl, *next_uattrl, *oattrl, *prev_oattrl, *next_oattrl;
	int found = 0, delete = 0, list_delete;
	char *last_inserted_attr = NULL;

	free(orig->name);
	free(orig->text);
	orig->name = upd->name;
	orig->text = upd->text;
	upd->name = NULL;
	upd->text = NULL;
	uattrl = upd->attribs;

	oattrl = orig->attribs; /* start matching from top of existing attr list */
	prev_oattrl = NULL;

	/* setting text, name, and attribute pointers to NULl so free_bs() from caller will not free these */
	CLI_DBPRT((stderr, "*** Updating object %s\n", orig->name))

	prev_uattrl = NULL;
	
	while (uattrl) {
		next_uattrl = uattrl->next; /* store next since it could be munged in processing */

		found = 0;
		list_delete = 0;
		if (!uattrl->value || uattrl->value[0] == '\0')
			delete = 1;
		else
			delete = 0;

		if (!last_inserted_attr || strcmp(uattrl->name, last_inserted_attr) != 0) {
			/* next attribute is the same as the last attr name inserted
			 * this means it must be one of the resource updates
			 * we need to insert back to back
			 */
			oattrl = orig->attribs; /* start matching from top of existing attr list */
			prev_oattrl = NULL;

			while (oattrl) {
				next_oattrl = oattrl->next; /* store next since it could be munged in processing */

				if (strcmp(uattrl->name, oattrl->name) == 0) {
						if (oattrl->resource == NULL) { /* not a resource attribute */
							found = 1;
							if (!delete)
								update_attr(oattrl, uattrl);
						} else { /* resource attr, find all entries of same name and delete */
							list_delete = 1;
						}

						if (delete || list_delete) {
							/* if value is empty, means attribute was unset, so delete attribute */
							CLI_DBPRT((stderr, "Deleting attribute %s(%s)=%s\n", oattrl->name, oattrl->resource, oattrl->value))

							if (prev_oattrl)
								prev_oattrl->next = next_oattrl;
							else /* this is the head */
								orig->attribs = next_oattrl; /* the head of the attribute list just got deleted */
								
							free_attrl(oattrl);
						}
						if (found)
							break; /* this was an exact match, so no need to search further */
				} else {
					if (list_delete)
						break;
					prev_oattrl = oattrl; /* no match, fill last_oattrl */
				}
				oattrl = next_oattrl;
			}
		}
		
		if (!found && (delete == 0)) {
			/* if we insert, we must take off from the uattrl list */
			if (prev_uattrl)
				prev_uattrl->next = next_uattrl;
			else
				upd->attribs = next_uattrl;

			last_inserted_attr = uattrl->name; /* store for comparison */
			insert_attr(orig, prev_oattrl, uattrl); /* uattrl will be lost */
			prev_oattrl = prev_oattrl->next;
		} else {
			prev_uattrl = uattrl; /* did not loose current rec, so curr rec becomes previous */
		}

		uattrl = next_uattrl; /* move to next updated attribute */
	}

	return 0;
}

/**
 * @brief
 *	creates the cache index
 *
 * @return erroc deo
 * @retval - 0 - success
 * @retval - 1 - error
 *
 */
int 
cc_create()
{
	if (cc_idx == NULL) {
		if ((cc_idx = pbs_idx_create(0, 0)) == NULL) {
			fprintf(stderr, "Failed to create client cache index\n");
			fprintf(stderr, "out of memory\n");
			return (1);
		}
	}
	return 0;
}

/**
 * @brief
 *	Destroys the cache index
 *
 */
void 
cc_destroy()
{
	struct batch_status *t_status;

	/* if any tree/list built before, delete */
	while (cc_head) {
		pbs_idx_delete(cc_idx, cc_head->name);
		t_status = cc_head;
		cc_head = cc_head->next;
		free_bs(t_status);
	}
	cc_tail = NULL;
	cc_head = NULL;
}

/**
 * @brief
 *	append batch structure to the cache
 * 
 * @param[in] bs - batch structure to append
 * 
 * @return erroc deo
 * @retval - 0 - success
 * @retval - 1 - error
 *
 */
int
cc_append(struct batch_status *bs)
{
	struct attrl *attr, *nxt, *prev = NULL;
	CLI_DBPRT((stderr, "*** Appending object %s, %p\n", bs->name, bs))

	if (!bs)
		return 1;

	if (pbs_idx_insert(cc_idx, bs->name, bs) != PBS_IDX_RET_OK) {
		fprintf(stderr, "Failed to insert object %s in index\n", bs->name);
		return 1;
	}

	bs->prev = cc_tail;
	bs->next = NULL;
	if (cc_tail)
		cc_tail->next = bs;
	if (!cc_head)
		cc_head = bs;
	cc_tail = bs;

	/* this is a new object, we need to clean up any empty attributes */
	attr = bs->attribs;
	while (attr) {
		nxt = attr->next;

		if (!attr->value || attr->value[0] == '\0') {
			/* remove this attribute from the list */
			if (prev)
				prev->next = attr->next; 
			else
				bs->attribs = attr->next;

			CLI_DBPRT((stderr, "Ignoring empty attr %s while appending object %s\n", attr->name, bs->name))
			free_attrl(attr);
		} else {
			CLI_DBPRT((stderr, "Inserting attr %s(%s)=%s\n", attr->name, attr->resource, attr->value))
			prev = attr;
		}

		attr = nxt;
	}

	return 0;
}

/**
 * @brief
 *	update batch structure in the cache
 * 
 * @param[in] bs_upd - batch structure to update
 * 
 * @return erroc deo
 * @retval - 0 - success
 * @retval - 1 - error
 *
 */
int
cc_update(struct batch_status *bs_upd)
{
	int rc = 0;
	void *ctx = NULL;
	struct batch_status *bs;

	if (!bs_upd)
		return 1;

	if (pbs_idx_find(cc_idx, (void **) &bs_upd->name, (void **) &bs, &ctx) == PBS_IDX_RET_OK) {
		rc = cc_update_obj(bs, bs_upd);
		free_bs(bs_upd); /* free the record that was found and replaced */
	} else {
		rc = cc_append(bs_upd);
	}
	pbs_idx_free_ctx(ctx);
	return rc;	
}

/**
 * @brief
 *	delete batch structure from the cache
 * 
 * @param[in] bs_del - batch structure to delete
 * 
 * @return erroc deo
 * @retval - 0 - success
 * @retval - 1 - error
 *
 */
int 
cc_delete(struct batch_status *bs_del)
{
	int rc = -1;
	void *ctx = NULL;
	struct batch_status *bs;

	if (!bs_del)
		return 1;

	if (pbs_idx_find(cc_idx, (void **) &bs_del->name, (void **) &bs, &ctx) == PBS_IDX_RET_OK) {
		struct batch_status *prev = bs->prev, *next = bs->next;

		CLI_DBPRT((stderr, "*** Deleting object %s\n", bs_del->name))

		if (pbs_idx_delete_byctx(ctx) == PBS_IDX_RET_OK) { /* remove from tree */
			if (prev)
				prev->next = next;
			if (next)
				next->prev = prev;
			if (cc_head == bs) /* first node */
				cc_head = next;
			if (cc_tail == bs) /* last node */
				cc_tail = prev;

			if (bs != bs_del)
				free_bs(bs); /* in case of qstat sometimes, the bs_del passed is from the cache itself */

			rc = 0;
		}
	}
	
	free_bs(bs_del); /* free the incoming record used to match */
	pbs_idx_free_ctx(ctx);

	return rc;	
}

/**
 * @brief
 *	helper function get a single object from the client cache
 *	This only creates a deep copy of the batch structures
 * 	
 * @param[out] phead - the list to be added to and returned
 * @param[in] src - the batch status with the object info
 *
 * @return int
 * @retval -1  - failed to allocate memory
 * @retval  0  - success
 * 
 */
int
cc_add_list(struct batch_status **phead, struct batch_status *src)
{
	static struct batch_status *prev = NULL;
	struct batch_status *rbs;
	if (!src)
		return -1;

	rbs = malloc(sizeof(struct batch_status));
	rbs->name = strdup(src->name);
	rbs->attribs = dup_attrl_list(src->attribs);
	if (src->text)
		rbs->text = strdup(src->text);
	else
		rbs->text = NULL;

	rbs->next = NULL;
	rbs->prev = NULL;

	if (*phead == NULL) /* new list being created */
		*phead = rbs;
	else 
		prev->next = rbs;

	prev = rbs;
	
	return 0;
}

/**
 * @brief
 *	get objects from the client cache
 *
 * @param[in] query_name_list - list of object names to get
 * 	returns a duplicate copy of the data in a new list
 *
 * @return batch_status array
 * @retval NULL  - failed to allocate memory
 * @retval !NULL - pointer to the object (batch_status structure)
 * 
 */
struct batch_status *
cc_get_next(char *name, struct batch_status *last)
{
	void *ctx;
	int rc;
	struct batch_status *bs = NULL;

	if (last) 
		return last->next;
	
	if (name) {
		ctx = NULL;
		/* specific name requested, so we add that and then loop through few next possibly qualifying */
		rc = pbs_idx_find(cc_idx, (void **) &name, (void **) &bs, &ctx);
		pbs_idx_free_ctx(ctx);
		if (rc != PBS_IDX_RET_OK) 
			return NULL;

		return bs;
	} 
	
	/* else return the head */
	return cc_head;
}

/**
 * @brief
 *	free obj list (of shallow copied structures)
 *
 * @param[in] phead - list to be freed
 *
 * @return batch_status array
 * @retval NULL  - failed to allocate memory
 * @retval !NULL - pointer to the object (batch_status structure)
 * 
 */
void 
cc_free_obj_list(struct batch_status *phead)
{
	struct batch_status *tmp;
	while (phead) {
		tmp = phead;
		phead = phead->next;
		/* do not free the contents, this is only a shallow copy */
		free(tmp);
	}
}

/**
 * @brief
 *	Does the client cache have any objects
 *
 * @return boolean
 * @retval 1 - client cache has objects
 * @retval 0 - client cache is empty
 * 
 */
struct batch_status *
cc_get_head()
{
	return (cc_head);
}