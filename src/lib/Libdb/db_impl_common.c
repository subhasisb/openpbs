/*
 * Copyright (C) 1994-2018 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */


/**
 * @file    db_postgres_common.c
 *
 * @brief
 *      This file contains Postgres specific implementation of functions
 *	to access the PBS postgres database.
 *	This is postgres specific data store implementation, and should not be
 *	used directly by the rest of the PBS code.
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */
#include "pbs_db.h"
#include "db_impl.h"
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <arpa/inet.h>
#include "ticket.h"

#define IPV4_STR_LEN	15

extern int pbs_decrypt_pwd(char *, int, size_t, char **);

char g_namespace[20] = "pbs";

aerospike as;

#define PBS_DB_CONN_RETRY_TIME 30 /* after waiting for this amount of seconds, connection is retried */

/**
 * An array of structures(of function pointers) for each of the database object
 */
impl_db_fn_t db_fn_arr[4] =
{
	{ /* PBS_DB_SVR */
		impl_db_save_svr,
		NULL,
		impl_db_load_svr,
		NULL,
		NULL,
		impl_db_del_attr_svr,
		NULL,
		impl_db_reset_svr
	},
	{ /* PBS_DB_SCHED */
		impl_db_save_sched,
		impl_db_delete_sched,
		impl_db_load_sched,
		impl_db_find_sched,
		NULL,
		impl_db_del_attr_sched,
		NULL,
		impl_db_reset_sched
	},
	{ /* PBS_DB_QUE */
		impl_db_save_que,
		impl_db_delete_que,
		impl_db_load_que,
		impl_db_find_que,
		NULL,
		impl_db_del_attr_que,
		NULL,
		impl_db_reset_que
	},
	{ /* PBS_DB_JOB */
		impl_db_save_job,
		impl_db_delete_job,
		impl_db_load_job,
		impl_db_find_job,
		NULL,
		impl_db_del_attr_job,
		NULL,
		impl_db_reset_job
	}
};


long db_time_now(int i)
{
	long			time_msec;
	struct timeval		tval;

	gettimeofday(&tval, NULL);
	time_msec = (tval.tv_sec * 1000L) + (tval.tv_usec/1000L);
	return time_msec;
}

/**
 * @brief
 *      Initialize a query state variable, before being used in a cursor
 *
 * @param[in]   conn - Database connection handle
 *
 * @return      Pointer to opaque cursor state handle
 * @retval      NULL - Failure to allocate memory
 * @retval      !NULL - Success - returns the new state variable
 *
 */
static void *
db_initialize_state(pbs_db_conn_t *conn, query_cb_t query_cb)
{
	db_query_state_t *state = malloc(sizeof(db_query_state_t));
	if (!state)
		return NULL;
	state->count = 0;
	state->row = 0;
	state->query_cb = query_cb;
	return state;
}

/**
 * @brief
 *      Destroy a query state variable.
 *      Clears the database resultset and free's the memory allocated to
 *      the state variable
 *
 * @param[in]   st - Pointer to the state variable
 *
 */
static void
db_destroy_state(void *st)
{
	db_query_state_t *state = st;
	if (state) {
		free(state);
	}
}

/**
 * @brief
 *	Initialize a multirow database cursor
 *
 * @param[in]	conn - Connected database handle
 * @param[in]	pbs_db_obj_info_t - The pointer to the wrapper object which
 *		describes the PBS object (job/resv/node etc) that is wrapped
 *		inside it.
 * @param[in]	pbs_db_query_options_t - Pointer to the options object that can
 *		contain the flags or timestamp which will effect the query.
 *
 * @return	void *
 * @retval	Not NULL  - success. Returns the opaque cursor state handle
 * @retval	NULL	   - Failure
 *
 */
void*
pbs_db_search(pbs_db_conn_t *conn, pbs_db_obj_info_t *obj, pbs_db_query_options_t *opts, query_cb_t query_cb)
{
	void *st;
	int ret;

	st = db_initialize_state(conn, query_cb);
	if (!st)
		return st;

	ret = db_fn_arr[obj->pbs_db_obj_type].impl_db_find_obj(conn, st, obj, opts);
	if (ret == -1) {
		db_destroy_state(st);
		return NULL;
	}

	return st;
}

/**
 * @brief
 *	Get the next row from the cursor. It also is used to get the first row
 *	from the cursor as well.
 *
 * @param[in]	conn - Connected database handle
 * @param[in]	state - The cursor state handle that was obtained using the
 *		pbs_db_cursor_init call.
 * @param[out]	pbs_db_obj_info_t - The pointer to the wrapper object which
 *		describes the PBS object (job/resv/node etc) that is wrapped
 *		inside it. The row data is loaded into this parameter.
 *
 * @return      Error code
 * @retval	-1  - Failure
 * @retval	0  - success
 * @retval	1  - Success but no more rows
 *
 */
int
pbs_db_cursor_next(pbs_db_conn_t *conn, void *st, pbs_db_obj_info_t *obj)
{
	return 1; /* no more rows */
}

/**
 * @brief
 *	Close a cursor that was earlier opened using a pbs_db_cursor_init call.
 *
 * @param[in]	conn - Connected database handle
 * @param[in]	state - The cursor state handle that was obtained using the
 *		pbs_db_cursor_init call.
 *
 */
int
pbs_db_cursor_close(pbs_db_conn_t *conn, void *state)
{
	int count = ((db_query_state_t *) state)->count;
	db_destroy_state(state);
	return count;
}

/**
 * @brief
 *	Delete an existing object from the database
 *
 * @param[in]	conn - Connected database handle
 * @param[in]	pbs_db_obj_info_t - Wrapper object that describes the object
 *		(and data) to delete
 *
 * @return      int
 * @retval	-1  - Failure
 * @retval       0  - success
 * @retval	 1 -  Success but no rows deleted
 *
 */
int
pbs_db_delete_obj(pbs_db_conn_t *conn, pbs_db_obj_info_t *obj)
{
	return 0;
	return (db_fn_arr[obj->pbs_db_obj_type].impl_db_delete_obj(conn, obj));
}

/**
 * @brief
 *	Load a single existing object from the database
 *
 * @param[in]	conn - Connected database handle
 * @param[in/out]pbs_db_obj_info_t - Wrapper object that describes the object
 *		(and data) to load. This parameter used to return the data about
 *		the object loaded
 *
 * @return      Error code
 * @retval       0  - success
 * @retval	-1  - Failure
 * @retval	 1 -  Success but no rows loaded
 *
 */
int
pbs_db_load_obj(pbs_db_conn_t *conn, pbs_db_obj_info_t *obj, int lock)
{
	return (db_fn_arr[obj->pbs_db_obj_type].impl_db_load_obj(conn, obj, lock));
}


/**
 * @brief
 *	Saves a new object into the database
 *
 * @param[in]	conn - Connected database handle
 * @param[in]	pbs_db_obj_info_t - Wrapper object that describes the object (and data) to insert
 * @param[in]	savetype - quick or full save
 *
 * @return      Error code
 * @retval	-1  - Failure
 * @retval	 0  - Success
 * @retval	 1  - Success but no rows inserted
 *
 */
int
pbs_db_save_obj(pbs_db_conn_t *conn, pbs_db_obj_info_t *obj, int savetype)
{
	return (db_fn_arr[obj->pbs_db_obj_type].impl_db_save_obj(conn, obj, savetype));
}

/**
 * @brief
 *	Delete attributes of an object from the database
 *
 * @param[in]	conn - Connected database handle
 * @param[in]	pbs_db_obj_info_t - Wrapper object that describes the object
 * @param[in]	id - Object id
 * @param[in]	attr_list - list of attributes to delete
 *
 * @return      Error code
 * @retval      0  - success
 * @retval     -1  - Failure
 *
 */
int
pbs_db_delete_attr_obj(pbs_db_conn_t *conn, pbs_db_obj_info_t *obj, void *obj_id, pbs_db_attr_list_t *attr_list) 
{
	return (db_fn_arr[obj->pbs_db_obj_type].impl_db_del_attr_obj(conn, obj, obj_id, attr_list));
}

/**
 * @brief
 *	Add/update attributes of an object to the database
 *
 * @param[in]	conn - Connected database handle
 * @param[in]	pbs_db_obj_info_t - Wrapper object that describes the object
 * @param[in]	id - Object id
 * @param[in]	attr_list - list of attributes to add/update
 *
 * @return      Error code
 * @retval       0  - success
 * @retval      -1  - Failure
 *
 */
int
pbs_db_add_update_attr_obj(pbs_db_conn_t *conn, pbs_db_obj_info_t *obj, void *obj_id, pbs_db_attr_list_t *attr_list) 
{
	return (db_fn_arr[obj->pbs_db_obj_type].impl_db_add_update_attr_obj(conn, obj, obj_id, attr_list));
}

/**
 * @brief
 *	Frees allocate memory of an Object
 *
 * @param[in]	obj - db object
 *
 * @return None
 *
 */
void
pbs_db_reset_obj(pbs_db_obj_info_t *obj)
{
	db_fn_arr[obj->pbs_db_obj_type].impl_db_reset_obj(obj);
}

/**
 * @brief
 *	Cleans up memory associated with a resultset (tht was returned from a
 *	call to a query)
 *
 * @param[in]	conn - Connected database handle
 *
 */
void
pbs_db_cleanup_resultset(pbs_db_conn_t *conn)
{
}

/**
 * @brief
 *	Get the number of rows from a cursor
 *
 * @param[in]	state - The opaque cursor state handle
 *
 * @return      Numer of rows in the cursor
 * @retval       0 or positive - Number of rows in cursor
 * @retval	-1  - Failure
 *
 *
 */
int
pbs_db_get_rowcount(void *st)
{
	return -1;
}

/**
 * @brief
 *	Start a database transaction
 *	If a transaction is already on, just increment the transactioin nest
 *	count in the database handle object
 *
 * @param[in]	conn - Connected database handle
 * @param[in]	isolation_level - Isolation level to set for the transaction
 * @param[in]	async - Set synchronous/asynchronous commit behavior
 *
 * @return      Error code
 * @retval       0  - success
 * @retval	-1  - Failure
 *
 */
int
pbs_db_begin_trx(pbs_db_conn_t *conn, int isolation_level, int async)
{
	return 0;
}


/**
 * @brief
 *	End a database transaction
 *	Decrement the transaction nest count in the connection object. If the
 *	count reaches zero, then end the database transaction.
 *
 * @param[in]	conn - Connected database handle
 * @param[in]	commit - If commit is PBS_DB_COMMIT, then the transaction is
 *			 commited. If commi tis PBS_DB_ROLLBACK, then the
 *			 transaction is rolled back.
 *
 * @return      Error code
 * @retval       0  - success
 * @retval	-1  - Failure
 * @retval	-2  - An inner level transaction had called rollback
 *
 */
int
pbs_db_end_trx(pbs_db_conn_t *conn, int commit)
{
	return 0;
}



/**
 * @brief
 *	Check whether connection to pbs dataservice is fine
 *
 * @param[in]	conn - Connected database handle
 *
 * @return      Connection status
 * @retval      -1 - Connection down
 * @retval	 0 - Connection fine
 *
 */
int
pbs_db_is_conn_ok(pbs_db_conn_t *conn)
{
	return 0;
}

/**
 * @brief
 *	Create a new connection structure and initialize the fields
 *
 * @param[in]   host - The hostname to connect to
 * @param[in]   timeout - The connection attempt timeout
 * @param[in]   have_db_control - Do we have db instance control
 * @param[out]  failcode - Output failure code if any
 * @param[out]  errmsg	 - Details of error
 * @param[in]   len	 - length of error messge variable
 *
 * @return      Pointer to initialized connection structure
 * @retval      NULL  - Failure
 * @retval      !NULL - Success
 *
 */
pbs_db_conn_t *
pbs_db_init_connection(char * host, int timeout, int have_db_control, int *failcode, char *errmsg, int len)
{
	pbs_db_conn_t *conn;
	/*
	 * calloc ensures that everything is initialized to zeros
	 * so no need to explicitly set fields to 0.
	 */
	conn = calloc(1, sizeof(pbs_db_conn_t));
	if (!conn) {
		*failcode = PBS_DB_NOMEM;
		return NULL;
	}

	conn->conn_data = malloc(sizeof(void *));
	if (!conn->conn_data) {
		free(conn);
		conn = NULL;
		*failcode = PBS_DB_NOMEM;
		return NULL;
	}

	if (host) {
		conn->conn_host = strdup(host);
		if (!conn->conn_host) {
			free(conn->conn_data);
			free(conn);
			conn = NULL;
			*failcode = PBS_DB_NOMEM;
			return NULL;
		}
	}
	conn->conn_state = PBS_DB_CONNECT_STATE_NOT_CONNECTED;
	conn->conn_timeout = timeout;
	conn->conn_have_db_control = have_db_control;
	conn->conn_db_err = malloc(4096); 

	if (have_db_control == 0)
		conn->conn_db_state = PBS_DB_STARTED; /* assume database to be up since we dont have control */
	else
		conn->conn_db_state = PBS_DB_DOWN; /* assume database to be down to start with */

	conn->conn_result_format = 1; /* default result format is binary */
	conn->conn_info = pbs_get_connect_string(host, conn->conn_timeout, failcode, errmsg, len);
	if (!conn->conn_info) {
		free(conn->conn_data);
		if (conn->conn_host)
			free(conn->conn_host);
		free(conn);
		conn = NULL;
		return NULL;
	}
	return conn;
}

/**
 * @brief
 *	Connect to the database
 *
 * @param[in]   conn - Previously initialized connection structure
 *
 * @return      Error code
 * @retval       PBS_DB_SUCCESS - Successful connect
 * @retval      !PBS_DB_SUCCESS - Failure code
 *
 */
int
pbs_db_connect(pbs_db_conn_t *conn)
{
	const char DEFAULT_HOST[] = "127.0.0.1";
	const int DEFAULT_PORT = 3000;
	aerospike *p_as = &as;
	as_error err;

	int failcode = PBS_DB_SUCCESS;
	as_config config;
	as_config_init(&config);
	
	if (! as_config_add_hosts(&config, DEFAULT_HOST, DEFAULT_PORT)) {
		printf("Invalid host(s) %s\n", DEFAULT_HOST);
		exit(-1);
	}
	
	as_config_set_user(&config, NULL, NULL);
	config.auth_mode = AS_AUTH_INTERNAL;

	aerospike_init(p_as, &config);	

	if (aerospike_connect(p_as, &err) != AEROSPIKE_OK) {
		aerospike_destroy(p_as);
		exit(-1);
	}

	conn->conn_db_handle = (void *) p_as;
	conn->conn_state = PBS_DB_CONNECT_STATE_CONNECTED;

	return failcode;
}

/**
 * @brief
 *	Disconnect from the database and frees all allocated memory.
 *
 * @param[in]   conn - Connected database handle
 *
 * @return      Error code
 * @retval       0  - success
 * @retval      -1  - Failure
 *
 */
void
pbs_db_disconnect(pbs_db_conn_t *conn)
{
	as_error err;
	aerospike *as = (aerospike *) conn->conn_db_handle;

	if (!as)
		return;

	// Disconnect from the database cluster and clean up the aerospike object.
	aerospike_close(as, &err);
	//aerospike_destroy(as);

	return;
}

/**
 * @brief
 *      Destroys a previously created connection structure
 *      and frees all memory associated with it.
 *
 * @param[in]   conn - Previously initialized connection structure
 *
 */
void
pbs_db_destroy_connection(pbs_db_conn_t *conn)
{
	if (!conn)
		return;

	if (conn->conn_db_err)
		free(conn->conn_db_err);

	if (conn->conn_info)
		free(conn->conn_info);

	if (conn->conn_host)
		free(conn->conn_host);

	if (conn->conn_data)
		free(conn->conn_data);

	pbs_db_disconnect(conn);

	free(conn);

	return;
}


/**
 * @brief
 *	Function to set the database error into the db_err field of the
 *	connection object
 *
 * @param[in]	conn - The connnection handle
 * @param[in]	fnc - Custom string added to the error message
 *			This can be used to provide the name of the
 *			functionality.
 * @param[in]	msg - Custom string added to the error message. This can be
 *			used to provide a failure message.
 */
void
impl_set_error(pbs_db_conn_t *conn, char *fnc, char *msg)
{
	char *str = "";
	char *p;
	char fmt[] = "%s %s failed: %s";

	if (conn->conn_db_err) {
		free(conn->conn_db_err);
		conn->conn_db_err = NULL;
	}

	p = str + strlen(str) - 1;
	while ((p >= str) && (*p == '\r' || *p == '\n'))
		*p-- = 0; /* supress the last newline */

	conn->conn_db_err = malloc(strlen(fnc) + strlen(msg) +
		strlen(str) + sizeof(fmt) + 1);
	if (!conn->conn_db_err)
		return;

	sprintf((char *) conn->conn_db_err, fmt, fnc, msg, str);
#ifdef DEBUG
	printf("%s\n", (char *) conn->conn_db_err);
	fflush(stdout);
#endif
}




/**
 * @brief
 *	Retrieves the database password for an user. Currently, the database
 *	password is retrieved from the file under server_priv, called db_passwd
 *	Currently, this function returns the same username as the password, if
 *	a password file is not found under server_priv. However, if a password
 *	file is found but is not readable etc, then an error (indicated by
 *	returning NULL) is returned.
 *
 * @param[in]	user - Name of the user
 * @param[out]  errmsg - Details of the error
 * @param[in]   len    - length of error messge variable
 *
 * @return      Password String
 * @retval	 NULL - Failed to retrieve password
 * @retval	!NULL - Pointer to allocated memory with password string.
 *			Caller should free this memory after usage.
 *
 */
char *
pbs_get_dataservice_password(char *user, char *errmsg, int len)
{
	char pwd_file[MAXPATHLEN+1];
	int fd;
	struct stat st;
	char buf[MAXPATHLEN+1];
	char *str;

#ifdef WIN32
	sprintf(pwd_file, "%s\\server_priv\\db_password", pbs_conf.pbs_home_path);
	if ((fd = open(pwd_file, O_RDONLY | O_BINARY)) == -1)
#else
	sprintf(pwd_file, "%s/server_priv/db_password", pbs_conf.pbs_home_path);
	if ((fd = open(pwd_file, O_RDONLY)) == -1)
#endif
	{
		return strdup(user);
	} else {
		if (fstat(fd, &st) == -1) {
			close(fd);
			snprintf(errmsg, len, "%s: stat failed, errno=%d", pwd_file, errno);
			return NULL;
		}
		if (st.st_size >= sizeof(buf)) {
			close(fd);
			snprintf(errmsg, len, "%s: file too large", pwd_file);
			return NULL;
		}

		if (read(fd, buf, st.st_size) != st.st_size) {
			close(fd);
			snprintf(errmsg, len, "%s: read failed, errno=%d", pwd_file, errno);
			return NULL;
		}
		buf[st.st_size] = 0;
		close(fd);

		if (pbs_decrypt_pwd(buf, PBS_CREDTYPE_AES, st.st_size, &str) != 0)
			return NULL;

		return (str);
	}
}

/**
 * @brief
 *	Escape any special characters contained in a database password.
 *	The list of such characters is found in the description of PQconnectdb
 *	at http://www.postgresql.org/docs/8.3/static/libpq-connect.html.
 *
 * @param[out]	dest - destination string, which will hold the escaped password
 * @param[in]	src - the original password string, which may contain characters
 *		      that must be escaped
 * @param[in]   len - amount of space in the destination string;  to ensure
 *		      successful conversion, this value should be at least one
 *		      more than twice the length of the original password string
 *
 * @return      void
 *
 */
void
escape_passwd(char *dest, char *src, int len)
{
	char *p = dest;

	while (*src && ((p - dest) < len)) {
		if (*src == '\'' || *src == '\\') {
			*p = '\\';
			p++;
		}
		*p = *src;
		p++;
		src++;
	}
	*p = '\0';
}

/**
 * @brief
 *	Creates the database connect string by retreiving the
 *      database password and appending the other connection
 *      parameters.
 *	If parameter host is passed as NULL, then the "host =" portion
 *	of the connection info is not set, allowing the database to
 *	connect to the default host (which is local).
 *
 * @param[in]   host - The hostname to connect to, if NULL the not used
 * @param[in]   timeout - The timeout parameter of the connection
 * @param[in]   err_code - The error code in case of failure
 * @param[out]  errmsg - Details of the error
 * @param[in]   len    - length of error messge variable
 *
 * @return      The newly allocated and populated connection string
 * @retval       NULL  - Failure
 * @retval       !NULL - Success
 *
 */
char *
pbs_get_connect_string(char *host, int timeout, int *err_code, char *errmsg, int len)
{
	char		*svr_conn_info;
	int			pquoted_len = 0;
	char		*p = NULL, *pquoted = NULL;
	char		*usr = NULL;
	pbs_net_t	hostaddr;
	struct 		in_addr in;
	char		hostaddr_str[IPV4_STR_LEN + 1];
	char		*q;
	char		template1[]="hostaddr = '%s' port = %d dbname = '%s' user = '%s' password = '%s' "
		"connect_timeout = %d";
	char		template2[]="port = %d dbname = '%s' user = '%s' password = '%s' "
		"connect_timeout = %d";

	usr = pbs_get_dataservice_usr(errmsg, len);
	if (usr == NULL) {
		*err_code = PBS_DB_AUTH_FAILED;
		return NULL;
	}

	p = pbs_get_dataservice_password(usr, errmsg, len);
	if (p == NULL) {
		free(usr);
		*err_code = PBS_DB_AUTH_FAILED;
		return NULL;
	}

	pquoted_len = strlen(p) * 2 + 1;
	pquoted = malloc(pquoted_len);
	if (!pquoted) {
		free(p);
		free(usr);
		*err_code = PBS_DB_NOMEM;
		return NULL;
	}

	escape_passwd(pquoted, p, pquoted_len);

	svr_conn_info = malloc(MAX(sizeof(template1), sizeof(template2)) +
		((host)?IPV4_STR_LEN:0) + /* length of IPv4 only if host is not NULL */
		5 + /* possible length of port */
		strlen(PBS_DATA_SERVICE_STORE_NAME) +
		strlen(usr) + /* NULL checked earlier */
		strlen(p) + /* NULL checked earlier */
		10); /* max 9 char timeout + null char */
	if (svr_conn_info == NULL) {
		free(pquoted);
		free(p);
		free(usr);
		*err_code = PBS_DB_NOMEM;
		return NULL;
	}

	if (host == NULL) {
		sprintf(svr_conn_info,
			template2,
			pbs_conf.pbs_data_service_port,
			PBS_DATA_SERVICE_STORE_NAME,
			usr,
			pquoted,
			timeout);
	} else {
		if ((hostaddr = get_hostaddr(host)) == (pbs_net_t)0) {
			free(pquoted);
			free(p);
			free(usr);
			snprintf(errmsg, len, "Could not resolve dataservice host %s", host);
			*err_code = PBS_DB_CONNFAILED;
			return NULL;
		}
		in.s_addr = htonl(hostaddr);
		q = inet_ntoa(in);
		if (!q) {
			free(pquoted);
			free(p);
			free(usr);
			snprintf(errmsg, len, "inet_ntoa failed, errno=%d", errno);
			*err_code = PBS_DB_CONNFAILED;
			return NULL;
		}
		strncpy(hostaddr_str, q, IPV4_STR_LEN);
		hostaddr_str[IPV4_STR_LEN] = '\0';

		sprintf(svr_conn_info,
			template1,
			hostaddr_str,
			pbs_conf.pbs_data_service_port,
			PBS_DATA_SERVICE_STORE_NAME,
			usr,
			pquoted,
			timeout);
	}
	memset(p, 0, strlen(p)); 			 /* clear password from memory */
	memset(pquoted, 0, strlen(pquoted)); /* clear password from memory */
	free(pquoted);
	free(p);
	free(usr);

	return svr_conn_info;
}

#ifdef WIN32
void
repl_slash(char *path)
{
	char *p = path;
	while (*p) {
		if (*p == '/')
			*p = '\\';
		p++;
	}
}
#endif

/**
 * @brief
 *	Function to start/stop the database service/daemons
 *	Basically calls the pbs_dataservice script/batch file with
 *	the specified command. It adds a second parameter
 *	"PBS" to the command string. This way the script/batch file
 *	knows that the call came from the pbs code rather than
 *	being invoked from commandline by the admin
 *
 * @return      Error code
 * @retval       !=0 - Failure
 * @retval         0 - Success
 *
 */
int
pbs_dataservice_control(char *cmd, char **errmsg)
{
	char dbcmd[2*MAXPATHLEN+1];
	int rc = 0;
	char errfile[MAXPATHLEN+1];
	struct stat stbuf;
	int fd;
	char *p;
#ifdef WIN32
	char buf[MAXPATHLEN+1];
#endif

	if (*errmsg != NULL) {
		free(*errmsg);
		*errmsg = NULL;
	}

#ifdef WIN32
	strcpy(buf, pbs_conf.pbs_home_path);
	repl_slash(buf);
	/* create unique filename by appending pid */
	sprintf(errfile, "%s\\spool\\db_errfile_%s_%d",
		buf, cmd, getpid());

	/* execute service startup and redirect output to file */
	strcpy(buf, pbs_conf.pbs_exec_path);
	repl_slash(buf);
	sprintf(dbcmd,
		"%s\\sbin\\pbs_dataservice %s PBS %d > %s 2>&1",
		buf,
		cmd,
		pbs_conf.pbs_data_service_port,
		errfile);
	rc = wsystem(dbcmd, INVALID_HANDLE_VALUE);
#else
	/* create unique filename by appending pid */
	sprintf(errfile, "%s/spool/db_errfile_%s_%d",
		pbs_conf.pbs_home_path,
		cmd,
		getpid());

	/* execute service startup and redirect output to file */
	sprintf(dbcmd,
		"PBS_CONF_FILE=%s; "
		"export PBS_CONF_FILE;"
		"%s/sbin/pbs_dataservice %s PBS %d > %s 2>&1",
		pbs_conf.pbs_conf_file,
		pbs_conf.pbs_exec_path,
		cmd,
		pbs_conf.pbs_data_service_port,
		errfile);
	rc = system(dbcmd);
	if (WIFEXITED(rc))
		rc = WEXITSTATUS(rc);
#endif

	if (rc != 0) {
		/* read the contents of errfile and load to errmsg */
		if ((fd = open(errfile, 0)) != -1) {
			if (fstat(fd, &stbuf) != -1) {
				*errmsg = malloc(stbuf.st_size+1);
				if (*errmsg == NULL) {
					close(fd);
					unlink(errfile);
					return -1;
				}
				read(fd, *errmsg, stbuf.st_size);
				*(*errmsg+stbuf.st_size)=0;
				p = *errmsg + strlen(*errmsg) - 1;
				while ((p >= *errmsg) && (*p == '\r' || *p == '\n'))
					*p-- = 0; /* suppress the last newline */
			}
			close(fd);
		}
	}
	unlink(errfile);
	return rc;
}

/**
 * @brief
 *	Function to check whether data-service is running
 *
 * @return      Error code
 * @retval      -1  - Error in routine
 * @retval       0  - Data service running on local host
 * @retval       1  - Data service not running
 * @retval       2  - Data service running on another host
 *
 */
int
pbs_status_db(char **errmsg)
{
	return (pbs_dataservice_control(PBS_DB_CONTROL_STATUS, errmsg));
}

/**
 * @brief
 *	Start the database daemons/service in synchronous mode.
 *  This function waits for the database to complete startup.
 *
 * @param[out]	errmsg - returns the startup error message if any
 *
 * @return       int
 * @retval       0     - success
 * @retval       !=0   - Failure
 *
 */
int
pbs_startup_db(char **errmsg)
{
	return (pbs_dataservice_control(PBS_DB_CONTROL_START, errmsg));
}

/**
 * @brief
 *	Start the database daemons/service in asynchronous mode.
 * This function does not wait for the database to complete startup.
 *
 * @param[out]	errmsg - returns the startup error message if any
 *
 * @return      int
 * @retval       0    - success
 * @retval       !=0  - Failure
 *
 */
int
pbs_startup_db_async(char **errmsg)
{
	return (pbs_dataservice_control(PBS_DB_CONTROL_STARTASYNC, errmsg));
}

/**
 * @brief
 *	Function to stop the database service/daemons
 *	This passes the parameter STOP to the
 *	pbs_dataservice script.
 *
 * @param[out]	errmsg - returns the db error message if any
 *
 * @return      Error code
 * @retval       !=0 - Failure
 * @retval        0  - Success
 *
 */
int
pbs_shutdown_db(char **errmsg)
{
	return (pbs_dataservice_control(PBS_DB_CONTROL_STOP, errmsg));
}

/**
 * @brief
 *	Function to stop the database service/daemons
 *	in an asynchronous manner.
 *	This passes the parameter STOPASYNC to the
 *	pbs_dataservice script, which initiates the
 *	the database stop and returns without waiting.
 *
 * @param[out]	errmsg - returns the db error message if any
 *
 * @return      Error code
 * @retval       !=0 - Failure
 * @retval        0  - Success
 *
 */
int
pbs_shutdown_db_async(char **errmsg)
{
	return (pbs_dataservice_control(PBS_DB_CONTROL_STOPASYNC, errmsg));
}

/**
 * @brief
 *	Function to escape special characters in a string
 *	before using as a column value in the database
 *
 * @param[in]	conn - Handle to the database connection
 * @param[in]	str - the string to escape
 *
 * @return      Escaped string
 * @retval        NULL - Failure to escape string
 * @retval       !NULL - Newly allocated area holding escaped string,
 *                       caller needs to free
 *
 */
char *
pbs_db_escape_str(pbs_db_conn_t *conn, char *str)
{
	char *val_escaped;
	int val_len;

	if (str == NULL)
		return NULL;

	val_len = strlen(str);
	/* Use calloc() to ensure the character array is initialized. */
	val_escaped = calloc(((2*val_len) + 1), sizeof(char)); /* 2*orig + 1 as per Postgres API documentation */
	if (val_escaped == NULL)
		return NULL;

	return val_escaped;
}

/**
 * @brief
 *	Translates the error code to an error message
 *
 * @param[in]   err_code - Error code to translate
 * @param[out]   err_msg - The translated error message (newly allocated memory)
 *
 */
void
get_db_errmsg(int err_code, char **err_msg)
{
	if (*err_msg) {
		free(*err_msg);
		*err_msg = NULL;
	}

	switch (err_code) {
		case PBS_DB_STILL_STARTING:
			*err_msg = strdup("PBS dataservice is still starting up");
			break;

		case PBS_DB_AUTH_FAILED:
			*err_msg = strdup("PBS dataservice authentication failed");
			break;

		case PBS_DB_NOMEM:
			*err_msg = strdup("PBS out of memory in connect");
			break;

		case PBS_DB_CONNREFUSED:
			*err_msg = strdup("PBS dataservice not running");
			break;

		case PBS_DB_CONNFAILED:
			*err_msg = strdup("Failed to connect to PBS dataservice");
			break;

		default:
			*err_msg = strdup("PBS dataservice error");
			break;
	}
}

/**
 * @brief
 *	Free the connect string associated with a connection
 *
 * @param[in]   conn - Previously initialized connection structure
 *
 */
void
pbs_db_free_conn_info(pbs_db_conn_t *conn)
{
	if (!conn || !conn->conn_info)
		return;

	memset(conn->conn_info, 0, strlen(conn->conn_info));
	free(conn->conn_info);
	conn->conn_info = NULL;
}

/**
 * @brief convert network to host byte order to unsigned long long
 *
 * @param[in]   x - Value to convert
 *
 * @return Value converted from network to host byte order. Return the original
 * value if network and host byte order are identical.
 */
unsigned long long
pbs_ntohll(unsigned long long x)
{
	if (ntohl(1) == 1)
		return x;

	/*
	 * htonl and ntohl always work on 32 bits, even on a 64 bit platform,
	 * so there is no clash.
	 */
	return (unsigned long long)(((unsigned long long) ntohl((x) & 0xffffffff)) << 32) | ntohl(((unsigned long long)(x)) >> 32);
}
