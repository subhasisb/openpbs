#!/bin/sh
# Copyright (C) 1994-2020 Altair Engineering, Inc.
# For more information, contact Altair at www.altair.com.
#
# This file is part of the PBS Professional ("PBS Pro") software.
#
# Open Source License Information:
#
# PBS Pro is free software. You can redistribute it and/or modify it under the
# terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.
# See the GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Commercial License Information:
#
# For a copy of the commercial license terms and conditions,
# go to: (http://www.pbspro.com/UserArea/agreement.html)
# or contact the Altair Legal Department.
#
# Altair’s dual-license business model allows companies, individuals, and
# organizations to create proprietary derivative works of PBS Pro and
# distribute them - whether embedded or bundled with other software -
# under a commercial license agreement.
#
# Use of Altair’s trademarks, including but not limited to "PBS™",
# "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
# trademark licensing policies.

. ${PBS_CONF_FILE:-/etc/pbs.conf}


trap cleanup 1 2 3 15

dir=`dirname $0`
CWD=`pwd`
upgrade=0
PBS_AES_SWITCH_VER='14.0'
change_locale=0
opt_err=1
opt="$1"

#---------------------------------------------------------------------------------------------------
# Schema handling functions

generate_schema_file () {
	cat <<-EOF > ${schema}
/*
 * contains sql code to re-create the PBS database schema
 *
 */

drop schema pbs cascade; -- Drop any existing schema called pbs
create schema pbs;	 -- Create a new schema called pbs
create extension hstore; -- Create the hstore extension if it does not exit
---------------------- VERSION -----------------------------

/*
 * Table pbs.info holds information about the schema
 * - The schema version, used for migrating and updating PBS
 */
CREATE TABLE pbs.info (
    pbs_schema_version TEXT    NOT NULL
);

INSERT INTO pbs.info values('1.4.0'); /* schema version */

---------------------- SERVER ------------------------------

/*
 * Table pbs.server holds server object information
 */
CREATE TABLE pbs.server (
    sv_savetm       TIMESTAMP   NOT NULL,
    sv_creattm      TIMESTAMP   NOT NULL,
    attributes      hstore      NOT NULL DEFAULT ''	
);

---------------------- SCHED -------------------------------

/*
 * Table pbs.scheduler holds scheduler instance information
 */
CREATE TABLE pbs.scheduler (
    sched_name      TEXT        NOT NULL,
    sched_savetm    TIMESTAMP   NOT NULL,
    sched_creattm   TIMESTAMP   NOT NULL,
    attributes      hstore      NOT NULL default '',	
    CONSTRAINT scheduler_pk PRIMARY KEY (sched_name)
);

---------------------- NODE --------------------------------

/*
 * Table pbs.mominfo_time holds information about the generation and time of 
 * the host to vnode map
 */
CREATE TABLE pbs.mominfo_time (
    mit_time    BIGINT,
    mit_gen     INTEGER
);

/*
 * Table pbs.node holds information about PBS nodes
 */
CREATE TABLE pbs.node (
    nd_name         TEXT        NOT NULL,
    mom_modtime     BIGINT,
    nd_hostname     TEXT        NOT NULL,
    nd_state        INTEGER     NOT NULL,
    nd_ntype        INTEGER     NOT NULL,
    nd_pque         TEXT,
    nd_index        INTEGER     NOT NULL,
    nd_savetm       TIMESTAMP   NOT NULL,
    nd_creattm      TIMESTAMP   NOT NULL,
    attributes      hstore      NOT NULL default '',
    CONSTRAINT pbsnode_pk PRIMARY KEY (nd_name)
);
CREATE INDEX nd_idx_cr
ON pbs.node
( nd_creattm );

---------------------- QUEUE -------------------------------

/*
 * Table pbs.queue holds queue information
 */
CREATE TABLE pbs.queue (
    qu_name     TEXT        NOT NULL,
    qu_type     INTEGER     NOT NULL,
    qu_creattm  TIMESTAMP   NOT NULL,
    qu_savetm   TIMESTAMP   NOT NULL,
    attributes  hstore      NOT NULL default '',
    CONSTRAINT queue_pk PRIMARY KEY (qu_name)
);
CREATE INDEX que_idx_cr
ON pbs.queue
( qu_creattm );


---------------------- RESERVATION -------------------------

/*
 * Table pbs.resv holds reservation information
 */
CREATE TABLE pbs.resv (
    ri_resvID       TEXT        NOT NULL,
    ri_queue        TEXT        NOT NULL,
    ri_state        INTEGER     NOT NULL,
    ri_substate     INTEGER     NOT NULL,
    ri_type         INTEGER     NOT NULL,
    ri_stime        BIGINT      NOT NULL,
    ri_etime        BIGINT      NOT NULL,
    ri_duration     BIGINT      NOT NULL,
    ri_tactive      INTEGER     NOT NULL,
    ri_svrflags     INTEGER     NOT NULL,
    ri_numattr      INTEGER     NOT NULL,
    ri_resvTag      INTEGER     NOT NULL,
    ri_un_type      INTEGER     NOT NULL,
    ri_fromsock     INTEGER     NOT NULL,
    ri_fromaddr     BIGINT      NOT NULL,
    ri_savetm       TIMESTAMP   NOT NULL,
    ri_creattm      TIMESTAMP   NOT NULL,
    attributes      hstore      NOT NULL default '',
    CONSTRAINT resv_pk PRIMARY KEY (ri_resvID)
);


---------------------- JOB ---------------------------------

/*
 * Table pbs.job holds job information
 */
CREATE TABLE pbs.job (
    ji_jobid        TEXT        NOT NULL,
    ji_state        INTEGER     NOT NULL,
    ji_substate     INTEGER     NOT NULL,
    ji_svrflags     INTEGER     NOT NULL,
    ji_numattr      INTEGER     NOT NULL,
    ji_ordering     INTEGER     NOT NULL,
    ji_priority     INTEGER     NOT NULL,
    ji_stime        BIGINT,
    ji_endtbdry     BIGINT,
    ji_queue        TEXT        NOT NULL,
    ji_destin       TEXT,
    ji_un_type      INTEGER     NOT NULL,
    ji_momaddr      BIGINT,
    ji_momport      INTEGER,
    ji_exitstat     INTEGER,
    ji_quetime      BIGINT,
    ji_rteretry     BIGINT,
    ji_fromsock     INTEGER,
    ji_fromaddr     BIGINT,
    ji_4jid         TEXT,
    ji_4ash         TEXT,
    ji_credtype     INTEGER,
    ji_qrank        INTEGER     NOT NULL,
    ji_savetm       TIMESTAMP   NOT NULL,
    ji_creattm      TIMESTAMP   NOT NULL,
    attributes      hstore      NOT NULL default '',
    CONSTRAINT jobid_pk PRIMARY KEY (ji_jobid)
);

CREATE INDEX job_rank_idx
ON pbs.job
( ji_qrank );


/*
 * Table pbs.job_scr holds the job script 
 */
CREATE TABLE pbs.job_scr (
    ji_jobid    TEXT       NOT NULL,
    script      TEXT
);
CREATE INDEX job_scr_idx ON pbs.job_scr (ji_jobid);

---------------------- END OF SCHEMA -----------------------
EOF
}

upgrade_pbs_schema_from_v1_0_0() {

	${PGSQL_DIR}/bin/psql -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} <<-EOF > /dev/null
		alter table pbs.node alter column nd_index drop default;
		alter table pbs.node drop constraint node_nd_index_key;
		create index job_scr_idx on pbs.job_scr (ji_jobid);
		drop sequence pbs.node_sequence;

		\set PBS_MAXHOSTNAME	'64'
		create sequence pbs.svr_id_seq;
		alter table pbs.server add column sv_hostname varchar(:PBS_MAXHOSTNAME);
		update pbs.server set sv_hostname = sv_name;
		alter table pbs.server alter column sv_hostname set not null;
	EOF
	ret=$?
	if [ $ret -ne 0 ]; then
		echo "Some datastore transformations failed to complete"
		echo "Please check dataservice logs"
		return $ret
	fi
}

upgrade_pbs_schema_from_v1_1_0() {

	${PGSQL_DIR}/bin/psql -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} <<-EOF > /dev/null
		ALTER TABLE pbs.info ALTER COLUMN pbs_schema_version TYPE text;
		ALTER TABLE pbs.job ALTER COLUMN ji_jobid TYPE text;
		ALTER TABLE pbs.job ALTER COLUMN ji_sv_name TYPE text;
		ALTER TABLE pbs.job ALTER COLUMN ji_queue TYPE text;
		ALTER TABLE pbs.job ALTER COLUMN ji_destin TYPE text;
		ALTER TABLE pbs.job ALTER COLUMN ji_4jid TYPE text;
		ALTER TABLE pbs.job ALTER COLUMN ji_4ash TYPE text;
		ALTER TABLE pbs.job_attr ALTER COLUMN ji_jobid TYPE text;
		ALTER TABLE pbs.job_attr ALTER COLUMN attr_name TYPE text;
		ALTER TABLE pbs.job_attr ALTER COLUMN attr_resource TYPE text;
		ALTER TABLE pbs.job_scr ALTER COLUMN ji_jobid TYPE text;
		ALTER TABLE pbs.node ALTER COLUMN nd_name TYPE text;
		ALTER TABLE pbs.node ALTER COLUMN nd_hostname TYPE text;
		ALTER TABLE pbs.node ALTER COLUMN nd_pque TYPE text;
		ALTER TABLE pbs.node_attr ALTER COLUMN nd_name TYPE text;
		ALTER TABLE pbs.node_attr ALTER COLUMN attr_name TYPE text;
		ALTER TABLE pbs.node_attr ALTER COLUMN attr_resource TYPE text;
		ALTER TABLE pbs.queue ALTER COLUMN qu_name TYPE text;
		ALTER TABLE pbs.queue ALTER COLUMN qu_sv_name TYPE text;
		ALTER TABLE pbs.queue_attr ALTER COLUMN qu_name TYPE text;
		ALTER TABLE pbs.queue_attr ALTER COLUMN attr_name TYPE text;
		ALTER TABLE pbs.queue_attr ALTER COLUMN attr_resource TYPE text;
		ALTER TABLE pbs.resv ALTER COLUMN ri_resvid TYPE text;
		ALTER TABLE pbs.resv ALTER COLUMN ri_sv_name TYPE text;
		ALTER TABLE pbs.resv ALTER COLUMN ri_queue TYPE text;
		ALTER TABLE pbs.resv_attr ALTER COLUMN ri_resvid TYPE text;
		ALTER TABLE pbs.resv_attr ALTER COLUMN attr_name TYPE text;
		ALTER TABLE pbs.resv_attr ALTER COLUMN attr_resource TYPE text;
		ALTER TABLE pbs.scheduler ALTER COLUMN sched_name TYPE text;
		ALTER TABLE pbs.scheduler ALTER COLUMN sched_sv_name TYPE text;
		ALTER TABLE pbs.scheduler_attr ALTER COLUMN sched_name TYPE text;
		ALTER TABLE pbs.scheduler_attr ALTER COLUMN attr_name TYPE text;
		ALTER TABLE pbs.scheduler_attr ALTER COLUMN attr_resource TYPE text;
		ALTER TABLE pbs.server ALTER COLUMN sv_name TYPE text;
		ALTER TABLE pbs.server ALTER COLUMN sv_hostname TYPE text;
		ALTER TABLE pbs.server_attr ALTER COLUMN sv_name TYPE text;
		ALTER TABLE pbs.server_attr ALTER COLUMN attr_name TYPE text;
		ALTER TABLE pbs.server_attr ALTER COLUMN attr_resource TYPE text;
		ALTER TABLE pbs.subjob_track ALTER COLUMN ji_jobid TYPE text;
		alter table pbs.job drop constraint job_pkey cascade;
		create index ji_jobid_idx on pbs.job (ji_jobid);
		drop index pbs.job_attr_idx;
		create index job_attr_idx on pbs.job_attr (ji_jobid, attr_name, attr_resource);
		alter table pbs.subjob_track drop constraint subjob_track_pkey cascade;
		create index subjob_jid_idx on pbs.subjob_track (ji_jobid, trk_index);
		update pbs.info set pbs_schema_version = '1.2.0';
	EOF
	ret=$?
	if [ $ret -ne 0 ]; then
		echo "Some datastore transformations failed to complete"
		echo "Please check dataservice logs"
		return $ret
	fi
}

upgrade_pbs_schema_from_v1_2_0() {

	${PGSQL_DIR}/bin/psql -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} <<-EOF > /dev/null
		DROP TABLE pbs.subjob_track;
		INSERT INTO pbs.scheduler (sched_name, sched_sv_name, sched_savetm, sched_creattm) VALUES ('default', '1', localtimestamp, localtimestamp);
		ALTER TABLE pbs.scheduler_attr DROP CONSTRAINT scheduler_attr_fk;
		UPDATE pbs.scheduler_attr SET sched_name='default' WHERE sched_name='1';
		ALTER TABLE pbs.scheduler_attr ADD CONSTRAINT scheduler_attr_fk
			FOREIGN KEY (sched_name)
			REFERENCES pbs.scheduler (sched_name)
			ON DELETE CASCADE
			ON UPDATE NO ACTION
			NOT DEFERRABLE;
		DELETE FROM pbs.scheduler WHERE sched_name='1';
		UPDATE pbs.info SET pbs_schema_version = '1.3.0';
	EOF
	ret=$?
	if [ $ret -ne 0 ]; then
		echo "Some datastore transformations failed to complete"
		echo "Please check dataservice logs"
		return $ret
	fi
}

upgrade_pbs_schema_from_v1_3_0() {

	${PGSQL_DIR}/bin/psql -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} <<-EOF > /dev/null
		ALTER TABLE pbs.job ADD CONSTRAINT jobid_pk PRIMARY KEY (ji_jobid);
	EOF
	ret=$?
	if [ $ret -ne 0 ]; then
		echo "Primary key violation"
		echo "Please check dataservice logs"
		return $ret
	fi

	${PGSQL_DIR}/bin/psql -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} <<-EOF > /dev/null
		
		CREATE EXTENSION hstore SCHEMA public;
		
		ALTER TABLE pbs.job ADD attributes hstore DEFAULT ''::hstore;
		UPDATE pbs.job SET attributes=(
			SELECT hstore(array_agg(attr.key ), array_agg(attr.value))
				FROM ( SELECT concat(attr_name, '.' , attr_resource) AS key,
					      concat(attr_flags, '.' , attr_value) AS value
						FROM pbs.job_attr WHERE pbs.job_attr.ji_jobid=pbs.job.ji_jobid) AS attr);
		UPDATE pbs.job SET attributes='' WHERE attributes IS NULL;
		ALTER TABLE pbs.job ALTER COLUMN attributes SET NOT NULL;

		ALTER TABLE pbs.node ADD attributes hstore DEFAULT ''::hstore;
		UPDATE pbs.node SET attributes=(
			SELECT hstore(array_agg(attr.key ), array_agg(attr.value))
				FROM ( SELECT concat(attr_name, '.' , attr_resource) AS key,
					      concat(attr_flags, '.' , attr_value) AS value
						FROM pbs.node_attr WHERE pbs.node_attr.nd_name=pbs.node.nd_name) AS attr);
		UPDATE pbs.node SET attributes='' WHERE attributes IS NULL;
		ALTER TABLE pbs.node ALTER COLUMN attributes SET NOT NULL;

		ALTER TABLE pbs.queue ADD attributes hstore DEFAULT ''::hstore;
		UPDATE pbs.queue SET attributes=(
			SELECT hstore(array_agg(attr.key ), array_agg(attr.value))
				FROM ( SELECT concat(attr_name, '.' , attr_resource) AS key,
					      concat(attr_flags, '.' , attr_value) AS value
						FROM pbs.queue_attr WHERE pbs.queue_attr.qu_name=pbs.queue.qu_name) AS attr);
		UPDATE pbs.queue SET attributes='' WHERE attributes IS NULL;
		ALTER TABLE pbs.queue ALTER COLUMN attributes SET NOT NULL;

		ALTER TABLE pbs.resv ADD attributes hstore DEFAULT ''::hstore;
		UPDATE pbs.resv SET attributes=(
			SELECT hstore(array_agg(attr.key ), array_agg(attr.value))
				FROM ( SELECT concat(attr_name, '.' , attr_resource) AS key,
					      concat(attr_flags, '.' , attr_value) AS value
						FROM pbs.resv_attr WHERE pbs.resv_attr.ri_resvid=pbs.resv.ri_resvid) AS attr);
		UPDATE pbs.resv SET attributes='' WHERE attributes IS NULL;
		ALTER TABLE pbs.resv ALTER COLUMN attributes SET NOT NULL;

		ALTER TABLE pbs.scheduler ADD attributes hstore DEFAULT ''::hstore;
		UPDATE pbs.scheduler SET attributes=(
			SELECT hstore(array_agg(attr.key ), array_agg(attr.value))
				FROM ( SELECT concat(attr_name, '.' , attr_resource) AS key,
					      concat(attr_flags, '.' , attr_value) AS value
						FROM pbs.scheduler_attr WHERE pbs.scheduler_attr.sched_name=pbs.scheduler.sched_name) AS attr);
		UPDATE pbs.scheduler SET attributes='' WHERE attributes IS NULL;
		ALTER TABLE pbs.scheduler ALTER COLUMN attributes SET NOT NULL;

		ALTER TABLE pbs.server ADD attributes hstore DEFAULT ''::hstore;
		UPDATE pbs.server SET attributes=(
			SELECT hstore(array_agg(attr.key ), array_agg(attr.value))
				FROM ( SELECT concat(attr_name, '.' , attr_resource) AS key,
					      concat(attr_flags, '.' , attr_value) AS value
						FROM pbs.server_attr WHERE pbs.server_attr.sv_name=pbs.server.sv_name) AS attr);
		UPDATE pbs.server SET attributes='' WHERE attributes IS NULL;
		ALTER TABLE pbs.server ALTER COLUMN attributes SET NOT NULL;

		DROP TABLE pbs.server_attr;
		DROP TABLE pbs.scheduler_attr;
		DROP TABLE pbs.node_attr;
		DROP TABLE pbs.queue_attr;		
		DROP TABLE pbs.resv_attr;
		DROP TABLE pbs.job_attr;
		DROP INDEX pbs.resv_idx_cr;
		DROP INDEX pbs.ji_jobid_idx;
		DROP sequence pbs.svr_id_seq;

		ALTER INDEX pbs.job_src_idx RENAME TO job_scr_idx;
		ALTER TABLE pbs.server ALTER COLUMN sv_jobidnumber TYPE BIGINT;
		ALTER TABLE pbs.scheduler DROP COLUMN sched_sv_name;
		ALTER TABLE pbs.queue DROP COLUMN qu_sv_name;
		ALTER TABLE pbs.resv DROP COLUMN ri_sv_name;
		ALTER TABLE pbs.job DROP COLUMN ji_sv_name;
		ALTER TABLE pbs.server
		DROP COLUMN sv_name,
		DROP COLUMN sv_hostname;

		UPDATE pbs.info SET pbs_schema_version = '1.4.0';
	EOF
	ret=$?
	if [ $ret -ne 0 ]; then
		echo "Some datastore transformations failed to complete"
		echo "Please check dataservice logs"
		return $ret
	fi
}

pbs_schema_upgrade () {
	# start of the upgrade schema script

	tmpdir=${PBS_TMPDIR:-${TMPDIR:-"/var/tmp"}}
	PBS_CURRENT_SCHEMA_VER='1.4.0'

	#
	# pbs_dataservice command now has more diagnostic output.
	# It can tell why it could not start, for example, that
	# dataservice might be running on another host.
	# So capture pbs_dataservice output and display in case of
	# errors during starting.
	#
	outfile="${tmpdir}/pbs_dataservice_output_$$"

	${PBS_EXEC}/sbin/pbs_dataservice status > /dev/null
	if [ $? -eq 0 ]; then
		# running stop now
		${PBS_EXEC}/sbin/pbs_dataservice stop > /dev/null
		if [ $? -ne 0 ]; then
			echo "Failed to stop PBS Dataservice"
			exit 1
		fi
	fi

	ret=$?
	if [ $ret -ne 0 ]; then
		return $ret
	fi

	# restart with new credentials
	# redirect the output, dont execute inside `` since
	# postgres processes would otherwise cause the script
	# to hang forever
	#
	${PBS_EXEC}/sbin/pbs_dataservice start > ${outfile}
	if [ $? -ne 0 ]; then
		cat ${outfile}
		rm -f ${outfile}
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi
		return 1
	fi
	rm -f ${outfile}

	ver=`${PGSQL_DIR}/bin/psql -A -t -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} -c "select pbs_schema_version from pbs.info"`
	if [ "$ver" = "${PBS_CURRENT_SCHEMA_VER}" ]; then
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi
		return 0
	fi

	if [ "$ver" = "1.0.0" ]; then
		upgrade_pbs_schema_from_v1_0_0
		ret=$?
		if [ $ret -ne 0 ]; then
			ret=$?
			if [ $ret -ne 0 ]; then
				return $ret
			fi
			return 1
		fi
		ver="1.1.0"
	fi

	${PBS_EXEC}/sbin/pbs_dataservice status > /dev/null
	if [ $? -eq 1 ]; then
		# not running, start now
		${PBS_EXEC}/sbin/pbs_dataservice start > ${outfile}
		if [ $? -ne 0 ]; then
			cat ${outfile}
			rm -f ${outfile}
			ret=$?
			if [ $ret -ne 0 ]; then
				return $ret
			fi
			return 1
		fi
		rm -f ${outfile}
	fi

	if [ "$ver" = "1.1.0" ]; then
		upgrade_pbs_schema_from_v1_1_0
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi
		ver="1.2.0"
	fi

	if [ "$ver" = "1.2.0" ]; then
		upgrade_pbs_schema_from_v1_2_0
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi
		ver="1.3.0"
	fi

	if [ "$ver" = "1.3.0" ]; then
		upgrade_pbs_schema_from_v1_3_0
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi
		ver="1.4.0"
	else
		echo "Cannot upgrade PBS datastore version $ver"
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi
		return 1
	fi

	${PBS_EXEC}/sbin/pbs_dataservice status > /dev/null
	if [ $? -eq 1 ]; then
		# not running, start now
		${PBS_EXEC}/sbin/pbs_dataservice start > ${outfile}
		if [ $? -ne 0 ]; then
			cat ${outfile}
			rm -f ${outfile}
			ret=$?
			if [ $ret -ne 0 ]; then
				return $ret
			fi
			return 1
		fi
	fi
	rm -f ${outfile}

	${PBS_EXEC}/sbin/pbs_dataservice stop > /dev/null

	ret=$?
	return $ret
}

#---------------------------------------------------------------------------------------------------
# Helper functions.
cleanup() {
	cd ${CWD}
	rm -rf ${data_dir}
	rm -f ${schema}
	rm -f ${tmp_file}
}

cleanup_on_finish () {
	# change back to our dir and quit
	cd ${CWD}
	err=`rm -f ${schema}`
	if [ $? -ne 0 ]; then
		echo "${err}"
	fi
}

set_db_trust_login() {
	datastore_dir=$1
	err=`cp -p ${datastore_dir}/pg_hba.conf ${datastore_dir}/pg_hba.conf.orig 2>&1`
	if [ $? -ne 0 ]; then
		echo "${err}"
		return 1
	fi
	err=`chown ${PBS_DATA_SERVICE_USER} ${datastore_dir}/pg_hba.conf.orig`
	if [ $? -ne 0 ]; then
		echo "${err}"
		return 1
	fi
	err=`sed 's/md5/trust/g' ${datastore_dir}/pg_hba.conf > ${datastore_dir}/pg_hba.conf.new 2>&1`
	if [ $? -ne 0 ]; then
		echo "${err}"
		return 1
	fi
	err=`chown ${PBS_DATA_SERVICE_USER} ${datastore_dir}/pg_hba.conf.new`
	if [ $? -ne 0 ]; then
		echo "${err}"
		return 1
	fi
	err=`mv ${datastore_dir}/pg_hba.conf.new ${datastore_dir}/pg_hba.conf 2>&1`
	if [ $? -ne 0 ]; then
		echo "${err}"
		return 1
	fi
}

revoke_db_trust_login() {
	datastore_dir=$1
	err=`cp -p ${datastore_dir}/pg_hba.conf.orig ${datastore_dir}/pg_hba.conf 2>&1`
	if [ $? -eq 0 ]; then
		rm -f ${datastore_dir}/pg_hba.conf.orig
	else
		echo "${err}"
		return 1
	fi
}

utf8_to_sql_ascii() {
	#
	# If the existing database has UTF-8 character encoding,
	# change the encoding to SQL_ASCII for database upgrade.
	#

	${PBS_EXEC}/sbin/pbs_dataservice status > /dev/null
	if [ $? -eq 0 ]; then
		# stop the dataservice
		${PBS_EXEC}/sbin/pbs_dataservice stop > /dev/null
		if [ $? -ne 0 ]; then
			echo "Error stopping PBS Data Service"
			kill -s SIGTERM `ps -ef | grep "${inst_dir}/bin/postgres" | grep -v grep | awk '{if ($3 == 1) print $2}'`
			return 1
		fi
	fi

	set_db_trust_login "${PBS_HOME}/datastore"
	ret=$?
	if [ $ret -ne 0 ]; then
		return $ret
	fi

	# restart with new credentials
	# redirect the output,
	# Use old pgsql binaries since we
	# are working with old database.
	#

	if [ -d "${PBS_HOME}/pgsql.old" ]; then
		PGSQL_INST_DIR="${PBS_HOME}/pgsql.old"
		export PGSQL_INST_DIR
	elif [ -d "${PBS_HOME}/pgsql.forupgrade" ]; then
		PGSQL_INST_DIR="${PBS_HOME}/pgsql.forupgrade"
		export PGSQL_INST_DIR
	fi

	${PBS_EXEC}/sbin/pbs_dataservice start > /dev/null
	if [ $? -ne 0 ]; then
		echo "Error starting PBS Data Service"
		revoke_db_trust_login "${PBS_HOME}/datastore"
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi
		return 1
	fi

	enc_type=`${PGSQL_INST_DIR}/bin/psql -A -t -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} -c "select pg_encoding_to_char(encoding) from pg_database where datname = 'pbs_datastore'"`
	if [ ! -z "${enc_type}" -a "${enc_type}" = "UTF8" ]; then
		db_list=`${PGSQL_INST_DIR}/bin/psql -A -t -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} -c "select datname from pg_database"`
		if [ $? -eq 0 ]; then
			for db_entry in ${db_list}
			do
				update=`${PGSQL_INST_DIR}/bin/psql -A -t -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} -c "update pg_database set encoding = pg_char_to_encoding('SQL_ASCII') where datname = '$db_entry'"`
				ret=$?
				if [ $ret -ne 0 ]; then
					return $ret
				fi
			done
		fi
	fi

	locale_collate=`${PGSQL_INST_DIR}/bin/psql -A -t -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} -c "SHOW LC_COLLATE"`
	if [ ! -z ${locale_collate} -a ${locale_collate} != "C" ]; then
		change_locale=1
	fi

	locale_ctype=`${PGSQL_INST_DIR}/bin/psql -A -t -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${PBS_DATA_SERVICE_USER} -c "SHOW LC_CTYPE"`
	if [ ! -z ${locale_ctype} -a ${locale_ctype} != "C" ]; then
		change_locale=1
	fi

	# stop the dataservice
	${PBS_EXEC}/sbin/pbs_dataservice stop > /dev/null
	if [ $? -ne 0 ]; then
		echo "Error stopping PBS Data Service"
		kill -s SIGTERM `ps -ef | grep "${PGSQL_INST_DIR}/bin/postgres" | grep -v grep | awk '{if ($3 == 1) print $2}'`
		return 1
	fi

	unset PGSQL_INST_DIR

	revoke_db_trust_login "${PBS_HOME}/datastore"
	ret=$?
	if [ $ret -ne 0 ]; then
		return $ret
	fi

	return 0
}

backupdir() {
	if [ -d "$1" -a -d "$2" ]; then
		backupdir="$(basename $1).pre.${PBS_VERSION}"
		echo "*** Backing up $1 to ${2}/${backupdir}"
		mv "$1" "${2}/${backupdir}"
	fi
}

# DB Upgrade functions
upgrade_pbs_database() {

	user="${PBS_DATA_SERVICE_USER}"
	inst_dir="${PGSQL_DIR}"
	data_dir="${PBS_HOME}/datastore"

	# Check for existence of old data service directory.
	if [ -d "${PBS_HOME}/pgsql.old" ]; then
		old_inst_dir="${PBS_HOME}/pgsql.old"
		old_data_dir="${PBS_HOME}/datastore.old"
	elif [ -d "${PBS_HOME}/pgsql.forupgrade" ]; then
		old_inst_dir="${PBS_HOME}/pgsql.forupgrade"
		old_data_dir="${PBS_HOME}/datastore.forupgrade"
	else
		echo "Data service directory from previous PBS installation not found,"
		echo "Datastore upgrade cannot continue"
		return 1
	fi

	if [ ! -f "${data_dir}/PG_VERSION" ]; then
		echo "Database version file: ${data_dir}/PG_VERSION not found, cannot continue"
		return 1
	fi
	
	sys_pgsql_ver=$(echo `${PGSQL_BIN}/postgres -V` | awk 'NR==1 {print $NF}' | cut -d '.' -f 1,2)
	old_pgsql_ver=`cat ${data_dir}/PG_VERSION`
	# strip the minor version from sys_pgsql_ver if old_pgsql_ver does not have minor version (for comparison).
	[[ ! $old_pgsql_ver =~ "." ]] && sys_pgsql_ver=$(echo $sys_pgsql_ver | cut -d '.' -f 1)

	[ ${sys_pgsql_ver%.*} -eq ${old_pgsql_ver%.*} ] && [ ${sys_pgsql_ver#*.} \> ${old_pgsql_ver#*.} ] || [ ${sys_pgsql_ver%.*} -gt ${old_pgsql_ver%.*} ];
	result=$?
	if [ ${result} -eq 0 ]; then
		if [ -d "$PBS_EXEC/pgsql" ]; then
			#Start upgrade process of datastore
			upgrade_db
			return $?
		else
			return 2
		fi
	elif [ "${old_pgsql_ver}" = "${sys_pgsql_ver}" ]; then
		return 0
	fi

	echo "Upgrade from version ${old_pgsql_ver} unsupported"
	return 1
}

upgrade_db() {
	#
	# This routine will insatll a 9.3 database cluster,
	# will perform the pre-upgrade checks for datastore
	# with appropriate authentication management.
	#

	server_ctl="${PBS_EXEC}/sbin/pbs_dataservice"
	if [ ! -x "${server_ctl}" ]; then
		echo "${server_ctl} not found"
		return 1
	fi

	if [ ! -x "${PBS_EXEC}/sbin/pbs_ds_password" ]; then
		echo "${PBS_EXEC}/sbin/pbs_ds_password not found"
		return 1
	fi

	if [ ! -x "${inst_dir}/bin/pg_upgrade" ]; then
		echo "${inst_dir}/bin/pg_upgrade not found"
		return 1
	fi

	# Check and convert UTF-8 character encoded database to SQL_ASCII
	utf8_to_sql_ascii
	if [ $? -ne 0 ]; then
		return 1
	fi

	# Backup datastore directory, if backup directory already
	# present then exit.
	if [ -d "${old_data_dir}" ]; then
		echo "Files from previous datastore upgrade found,"
		echo "Datastore upgrade cannot continue"
		return 1
	else
		err=`mv ${data_dir} ${old_data_dir} 2>&1`
		if [ $? -ne 0 ]; then
			echo "${err}"
			return 1
		fi
	fi

	# Invoke the dataservice creation script for pbs

	upgrade=1
	pbs_install_db
	ret=$?

	if [ ${ret} -ne 0 ]; then
		echo "*** Error initializing the PBS dataservice"
		echo "Error details:"
		echo "$resp"
		return ${ret}
	fi

	# Copy the pg_hba.conf from old cluster.
	err=`cp -p ${old_data_dir}/pg_hba.conf ${data_dir}/pg_hba.conf`
	if [ $? -ne 0 ]; then
		echo "${err}"
		return 1
	fi

	set_db_trust_login "${data_dir}"
	ret=$?
	if [ $ret -ne 0 ]; then
		return $ret
	fi
	set_db_trust_login "${old_data_dir}"
	ret=$?
	if [ $ret -ne 0 ]; then
		return $ret
	fi

	CWD=`pwd`
	cd "${data_dir}"
	#Perform pg_upgrade -c to check if we can upgrade the cluster or not
	err=`su ${user} -c "/bin/sh -c '${PGSQL_LIBSTR} ${inst_dir}/bin/pg_upgrade -b ${old_inst_dir}/bin -B ${inst_dir}/bin -d ${old_data_dir} -D ${data_dir} -c'" 2>&1`
	if [ $? -ne 0 ]; then
		echo "Refer pg_upgrade log files at $PBS_HOME/datastore/pg_upgrade_internal.log,"
		echo "$PBS_HOME/datastore/pg_upgrade_server.log and"
		echo "$PBS_HOME/datastore/pg_upgrade_utility.log for more information"
		revoke_db_trust_login "${data_dir}"
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi

		revoke_db_trust_login "${old_data_dir}"
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi

		return 1
	fi

	#Perform pg_upgrade for database upgrade
	err=`su ${user} -c "/bin/sh -c '${PGSQL_LIBSTR} ${inst_dir}/bin/pg_upgrade -b ${old_inst_dir}/bin -B ${inst_dir}/bin -d ${old_data_dir} -D ${data_dir}'" 2>&1`
	if [ $? -ne 0 ]; then
		echo "Refer pg_upgrade log files at $PBS_HOME/datastore/pg_upgrade_internal.log,"
		echo "$PBS_HOME/datastore/pg_upgrade_server.log and"
		echo "$PBS_HOME/datastore/pg_upgrade_utility.log for more information"
		revoke_db_trust_login "${data_dir}"
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi

		revoke_db_trust_login "${old_data_dir}"
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi

		return 1
	fi

	# start the dataservice
	${server_ctl} start > /dev/null
	if [ $? -ne 0 ]; then
		echo "Error starting PBS Data Service"
		return 1
	fi

	# Optimizer statistics are not transferred by pg_upgrade, so do it manually.
	ENVSTR="PGPORT=${PBS_DATA_SERVICE_PORT}; export PGPORT; PGHOST=${PBS_SERVER}; export PGHOST; PGUSER=${user}; export PGUSER; "
	err=`su ${user} -c "/bin/sh -c '${PGSQL_LIBSTR} ${ENVSTR} ${data_dir}/analyze_new_cluster.sh'"`

	# Update locale of pbs database to C
	if [ ${change_locale} -eq 1 ]; then
		${inst_dir}/bin/psql -A -t -p ${PBS_DATA_SERVICE_PORT} -d pbs_datastore -U ${user} -c "update pg_database set datcollate='C', datctype='C'" > /dev/null
		ret=$?
		if [ $ret -ne 0 ]; then
			return $ret
		fi
	fi

	# stop the dataservice
	${server_ctl} stop > /dev/null
	if [ $? -ne 0 ]; then
		echo "Error stopping PBS Data Service"
		kill -s SIGTERM `ps -ef | grep "${inst_dir}/bin/postgres" | grep -v grep | awk '{if ($3 == 1) print $2}'`
		return 1
	fi
	revoke_db_trust_login "${data_dir}"
	ret=$?
	if [ $ret -ne 0 ]; then
		return $ret
	fi

	cd "${CWD}"
	# Delete old cluster
	err=`${data_dir}/delete_old_cluster.sh`
	ret=$?
	if [ $ret -ne 0 ]; then
		return $ret
	fi
}


pbs_install_db () {
	locale=""
	if [ "${change_locale}" = "0" ]; then
		locale="--locale=C"
	fi

	if [ ! -z "${PBS_DATA_SERVICE_HOST}" ]; then
		echo "Custom data service host used...configure manually"
		exit 0
	fi

	if [ -z "${PBS_DATA_SERVICE_PORT}" ]; then
		PBS_DATA_SERVICE_PORT="15007"
	fi
	export PBS_DATA_SERVICE_PORT

	bin_dir="${PGSQL_BIN}"
	data_dir="${PBS_HOME}/datastore"
	server_ctl="${PBS_EXEC}/sbin/pbs_dataservice"
	tmp_file="${PBS_HOME}/spool/tmp_inst_$$"
	db_user="${PBS_HOME}/server_priv/db_user"

	# Get non symbolic absolute path of pgsql directory
	real_inst_dir="`/bin/ls -l $PBS_EXEC | awk '{print $NF "/pgsql"}'`"

	schema="${PBS_HOME}/spool/pbs_install_db_schema"
	generate_schema_file
	chmod 600 ${schema}
	if [ $? -ne 0 ]; then
		echo "chmod of ${schema} failed"
		rm -f ${schema}
		exit 1
	fi

	lwd=`pwd`

	if [ ! -d "${bin_dir}" ]; then
		# Using the system installed Postgres instead
		initdb_loc=`type initdb 2>/dev/null | cut -d' ' -f3`
		if [ -z "$initdb_loc" ]; then
			echo "PBS Data Service directory ${bin_dir}"
			echo "not present and postgresql-server not installed."
			rm -f ${schema}
			exit 1
		fi
		bin_dir=`dirname $initdb_loc`
	fi

	user="${PBS_DATA_SERVICE_USER}"
	port="${PBS_DATA_SERVICE_PORT}"

	chown ${user} ${schema}
	if [ $? -ne 0 ]; then
		echo "chown of ${schema} to user ${user} failed"
		rm -f ${schema}
		exit 1
	fi

	if [ ! -x "${bin_dir}/initdb" ]; then
		echo "${bin_dir} exists, binaries missing...exiting"
		rm -f ${schema}
		exit 1
	fi

	if [ -d "${data_dir}/base" ]; then
		olduser=`ls -ld ${data_dir} | awk '{print $3}'`
		if [ $? -ne 0 ]; then
		echo "Failed to stat directory ${data_dir}"
		rm -f ${schema}
		exit 1
		fi
		if [ "$olduser" != "$user" ]; then
		echo "Existing PBS Data Store ${data_dir} owned by different user ${olduser}"
		echo "Use the same user name or install in a different location"
		rm -f ${schema}
		exit 1
		fi
		rm -f ${schema}
		exit 2
	fi

	if [ ! -d "${data_dir}" ]; then
		mkdir -p "${data_dir}"
		if [ $? -ne 0 ]; then
			echo "Error creating dir ${data_dir}"
			rm -f ${schema}
			exit 1
		fi
	fi

	# delete the password file, if any, since we are creating new db
	[ ${upgrade} -eq 0 ] && rm -f "${PBS_HOME}/server_priv/db_password"
	passwd="${user}"

	chown ${user} ${data_dir}
	if [ $? -ne 0 ]; then
		echo "Chown of ${data_dir} to user ${user} failed"
		rm -f ${schema}
		exit 1
	fi

	chmod 700 ${data_dir}
	if [ $? -ne 0 ]; then
		echo "chmod of ${data_dir} failed"
		rm -f ${schema}
		exit 1
	fi

	echo "Creating the PBS Data Service..."

	# change directory to data_dir to ensure that we don't get cd errors from postgres later
	cd ${data_dir}

	err=`su ${user} -s /bin/sh -c "/bin/sh -c '${PGSQL_LIBSTR} ${bin_dir}/initdb -D ${data_dir} -U \"${user}\" -E SQL_ASCII ${locale}'" 2>&1`

	if [ $? -ne 0 ]; then
		echo "$err"
		echo "Error creating PBS datastore"
		cleanup
		exit 1
	fi

	# check for postgres config files existence
	if [ ! -f "${data_dir}/postgresql.conf" ]; then
		echo "PBS Data Sevice Config files not found"
		cleanup
		exit 1
	fi

	if [ ! -f "${data_dir}/pg_hba.conf" ]; then
		echo "PBS Data Sevice Config files not found"
		cleanup
		exit 1
	fi

	# update postgresql.conf 
	sed "{
		s/#checkpoint_segments = 3/checkpoint_segments = 20/g
		s/#port = 5432/port = ${port}/g
		s/#listen_addresses = 'localhost'/listen_addresses = '*'/g
		s/#standard_conforming_strings = off/standard_conforming_strings = on/g
		s/#logging_collector = off/logging_collector = on/g
		s/#log_directory = 'pg_log'/log_directory = 'pg_log'/g
		s/#log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'/log_filename = 'pbs_dataservice_log.%a'/g
		s/#log_truncate_on_rotation = off/log_truncate_on_rotation = on/g
		s/#log_rotation_age = 1d/log_rotation_age = 1440/g
		s/#log_line_prefix = ''/log_line_prefix = '%t'/g
		}" ${data_dir}/postgresql.conf > ${tmp_file}
	if [ $? -ne 0 ]; then
		echo "Error creating PBS datastore"
		cleanup
		exit 1
	fi
	mv ${tmp_file} ${data_dir}/postgresql.conf
	if [ $? -ne 0 ]; then
		echo "Error moving ${tmp_file} to ${data_dir}/postgresql.conf"
		cleanup
		exit 1
	fi

	chown ${user} ${data_dir}/postgresql.conf
	if [ $? -ne 0 ]; then
		echo "Error setting ownership to file ${data_dir}/postgresql.conf"
		cleanup
		exit 1
	fi

	chmod 600 ${data_dir}/postgresql.conf
	if [ $? -ne 0 ]; then
		echo "Error setting permissions to file ${data_dir}/postgresql.conf"
		cleanup
		exit 1
	fi
	
	# Copy pgsql directory to PBS_HOME (as pgsql.forupgrade) for it's future upgrade
	[ ! -d "${PBS_HOME}/pgsql.forupgrade" -a -d "${PBS_EXEC}/pgsql" -a -d "${PBS_HOME}" ] && cp -pr --no-preserve=timestamps "${PBS_EXEC}/pgsql" "${PBS_HOME}/pgsql.forupgrade" 2>&1

	if [ $upgrade -eq 1 ]; then
		cleanup_on_finish
		exit 0
	fi

	# Add IPV6 local address to pg_hba.conf so the pbs_ds_password is fine
	echo "host    all             all             ::1/128                 trust" >> ${data_dir}/pg_hba.conf

	${server_ctl} start 
	if [ $? -ne 0 ]; then
		echo "Error starting PBS Data Service"
		cleanup
		exit 1
	fi
	# Wait for postgres to start.
	tries=5
	while [ $tries -ge 0 ]
	do
		${server_ctl} status > /dev/null 2>&1
		ret=$?
		if [ $ret -eq 0 ]; then
			break
		fi
		tries=$((tries-1))
		sleep 2
	done
	if [ $ret -ne 0 ]; then
		echo "Error starting PBS Data Service"
		cleanup
		exit 1
	fi

	err=`su ${user} -s /bin/sh -c "/bin/sh -c '${PGSQL_LIBSTR} ${bin_dir}/createdb -p ${port} pbs_datastore'" 2>&1`

	if [ $? -ne 0 ]; then
		echo "$err"
		echo "Error creating PBS datastore"
		${server_ctl} stop > /dev/null 2>&1
		cleanup
		exit 1
	fi

	# now install the pbs datastore schema onto the datastore
	err=`su ${user} -s /bin/sh -c "/bin/sh -c '${PGSQL_LIBSTR} ${bin_dir}/psql -p ${port} -d pbs_datastore -U \"${user}\" -f ${schema}'" 2>&1`

	if [ $? -ne 0 ]; then
		echo $err
		echo "Error initializing PBS datastore"
		${server_ctl} stop > /dev/null 2>&1
		cleanup
		exit 1
	fi

	err=`${PBS_EXEC}/sbin/pbs_ds_password -r`
	if [ $? -ne 0 ]; then
		echo $err
		echo "Error setting password for PBS Data Service"
		${server_ctl} stop > /dev/null 2>&1
		cleanup
		exit 1
	fi

	# stop the dataservice
	${server_ctl} stop
	if [ $? -ne 0 ]; then
		echo $err
		echo "Error stopping PBS Data Service"
		kill -TERM `ps -ef | grep "${bin_dir}/postgres" | grep -v grep | awk '{if ($3 == 1) print $2}'`
		cleanup
		exit 1
	fi

	# update the pg_hba.conf, so that no passwordless entry is allowed
	num=`grep -n "#.*TYPE.*DATABASE.*USER.*ADDRESS.*METHOD" ${data_dir}/pg_hba.conf | awk -F: '{print $1}'`
	head -n $num ${data_dir}/pg_hba.conf > ${tmp_file}
	mv ${tmp_file} ${data_dir}/pg_hba.conf

	echo "# IPv4 local connections: " >> ${data_dir}/pg_hba.conf
	echo "local   all             all                                     md5" >> ${data_dir}/pg_hba.conf
	echo "host    all             all             0.0.0.0/0               md5" >> ${data_dir}/pg_hba.conf
	echo "host    all             all             127.0.0.1/32            md5" >> ${data_dir}/pg_hba.conf
	echo "# IPv6 local connections:" >> ${data_dir}/pg_hba.conf
	echo "host    all             all             ::1/128                 md5" >> ${data_dir}/pg_hba.conf

	chown ${user} ${data_dir}/pg_hba.conf
	chmod 600 ${data_dir}/pg_hba.conf

	cleanup_on_finish
	exit 0
}

if [ "${opt}" = "upgrade_db" ]; then
	opt_err=0
	# Store the old PBS VERSION for later use
	if [ -f "$PBS_HOME/pbs_version" ]; then
		old_pbs_version=`cat $PBS_HOME/pbs_version`
	fi

	upgrade_pbs_database
	ret=$?
	if [ $ret -ne 0 ]; then
		if [ $ret -eq 2 ]; then
			echo "It appears that PostgreSQL has been upgraded independently of PBS Pro."
			echo "The PBS Pro database must be manually upgraded. Please refer to the"
			echo "documentation/release notes for details."
		else 
			echo "Failed to upgrade PBS Datastore"
		fi
		exit $ret
	else
		if [ -d "${old_inst_dir}" ]; then
			backupdir "$old_inst_dir" "$PBS_HOME"
			if [ $? -ne 0 ]; then
				echo "Failed to backup $old_inst_dir, please follow the below instructions:"
				echo "*** Backup "$old_inst_dir" if you need to downgrade pgsql later on."
				echo "*** For future upgrades to be successful run the below command."
				echo "*** cp -pr ${PBS_EXEC}/pgsql ${PBS_HOME}/pgsql.forupgrade"
			else
				echo "*** ${PBS_HOME}/$(basename ${old_inst_dir}).pre.${PBS_VERSION} may need to be manually removed if you do not wish to downgrade PBSPro."
			fi
		fi
	fi

	# do schema upgrade
	set_db_trust_login "${PBS_HOME}/datastore"
	pbs_schema_upgrade
	ret=$?
	if [ $ret -ne 0 ]; then
		revoke_db_trust_login "${PBS_HOME}/datastore"
		echo "Failed to upgrade PBS Datastore"
		exit $ret
	fi

	# We need to regenerate the db_password file since we have changed encryption/decryption
	# library from DES to AES in PBS Version PBS_AES_SWITCH_VER
	if [ "$old_pbs_version" \< "${PBS_AES_SWITCH_VER}" ] ;then
		rm -f  "${PBS_HOME}/server_priv/db_password"
		err=`${PBS_EXEC}/sbin/pbs_ds_password -r`
		if [ $? -ne 0 ]; then
			echo $err
			echo "Error setting password for PBS Data Service"
			${server_ctl} stop > /dev/null 2>&1
			revoke_db_trust_login "${PBS_HOME}/datastore"
			exit 1
		fi
	fi
	revoke_db_trust_login "${PBS_HOME}/datastore"


elif [ "${opt}" = "install_db" ]; then
	opt_err=0
	pbs_install_db
fi

if [ "${opt_err}" -eq 1 ]; then
	echo "Usage: pbs_db_utility [install_db|upgrade_db]"
	exit 1
fi
